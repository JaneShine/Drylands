上一篇文章我们聊到如何对牌型进行规划。这期继续上次的流程，牌型规划后，我们需要决策有多种组合方式时，应该如何行牌。先回忆一下我们的公式：

$$a * x_1 + b * x_2 + c * x_3 + d * x_4 ... + n * x_n + \epsilon = N$$

$$argmin(\epsilon)$$

其中，N为特定玩家的手牌总张数， $x_n$ 为某种组合的数量，系数为某种组合所需要的牌张数，上述公式中的所有符号均属于正整数。

上期的`find_combo()`输出结果为所有可能的set组合方式，例如对于手牌：`array([3, 3, 4, 6, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 14, 15, 15, 15, 42, 43])`, 分组结果为：
```
[[6, array([0, 1, 0, 1, 0, 1, 0]), [6, 13], '连对'],
 [6, array([0, 1, 0, 1, 0]), [6, 11], '连对'],
 [8, array([0, 1, 0, 1, 0]), [8, 13], '连对'],
 [0, array([0]), [0, 1], '对子'],
 [3, array([0]), [3, 4], '对子'],
 [6, array([0]), [6, 7], '对子'],
 [8, array([0]), [8, 9], '对子'],
 [10, array([0]), [10, 11], '对子'],
 [12, array([0]), [12, 13], '对子']]
```
对于组合[6, array([0, 1, 0, 1, 0, 1, 0]), [6, 13], '连对']，其数据信息含义是：从index=6开始，到index=13结束，存在连对（8、8，9、9，10、10，J、J）。

因此构造目标优化函数

```
def __objective(x:np.array, params:list, N:int):
    '''the objective function
        x: 1 for existence of a set else 0
        params: 组合index起始终止向量
        N: 手牌总数
        
    '''
    total = np.sum(params * x.reshape(-1, 1), axis=0)
    return np.abs(np.sum(total) - N)
    

```

